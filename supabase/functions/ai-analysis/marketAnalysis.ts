export interface Candle{time:number;open:number;high:number;low:number;close:number;volume:number}export interface SwingPoint{index:number;price:number;type:'high'|'low';time:number}export interface BOSResult{detected:boolean;type:'bullish'|'bearish'|null;breakLevel:number|null;strength:number}export interface LiquiditySweepResult{detected:boolean;sweptLevel:number|null;sweptType:'high'|'low'|null;strength:number}export interface MarketStructureAnalysis{bos:BOSResult;liquiditySweep:LiquiditySweepResult;trend:'bullish'|'bearish'|'sideways';trendStrength:number;orderBlocks:Array<{price:number;type:'bullish'|'bearish';strength:number}>;fvgs:Array<{top:number;bottom:number;type:'bullish'|'bearish'}>;keyLevels:{support:number[];resistance:number[]}}export interface PairAnalysis{symbol:string;displayName:string;structure:MarketStructureAnalysis;currentPrice:number;priceChange24h:number}export async function fetchMultiTimeframeData(symbol:string,polygonKey:string):Promise<Record<string,Candle[]>>{const timeframes={'M15':{multiplier:15,timespan:'minute',limit:500},'H1':{multiplier:1,timespan:'hour',limit:300},'H4':{multiplier:4,timespan:'hour',limit:200}};const result:Record<string,Candle[]>={};const forex=symbol.replace('/','');const to=Date.now();for(const[tf,config]of Object.entries(timeframes)){try{const from=to-(config.limit*config.multiplier*(config.timespan==='hour'?60:1)*60*1000);const url=`https://api.polygon.io/v2/aggs/ticker/C:${forex}/range/${config.multiplier}/${config.timespan}/${from}/${to}?adjusted=true&sort=asc&limit=${config.limit}&apiKey=${polygonKey}`;const response=await fetch(url);if(response.ok){const data=await response.json();if(data.results&&data.results.length>0){result[tf]=data.results.map((bar:any)=>({time:bar.t,open:bar.o,high:bar.h,low:bar.l,close:bar.c,volume:bar.v||1000}))}}await new Promise(resolve=>setTimeout(resolve,120))}catch(error){console.error(`Error fetching ${tf} for ${symbol}:`,error)}}return result}function findSwingPoints(candles:Candle[],strength:number=3):SwingPoint[]{const swings:SwingPoint[]=[];const lookback=Math.min(100,candles.length);const startIndex=Math.max(0,candles.length-lookback);for(let i=startIndex+strength;i<candles.length-strength;i++){const current=candles[i];let isSwingHigh=true;for(let j=i-strength;j<=i+strength;j++){if(j!==i&&candles[j].high>=current.high){isSwingHigh=false;break}}if(isSwingHigh){swings.push({index:i,price:current.high,type:'high',time:current.time})}let isSwingLow=true;for(let j=i-strength;j<=i+strength;j++){if(j!==i&&candles[j].low<=current.low){isSwingLow=false;break}}if(isSwingLow){swings.push({index:i,price:current.low,type:'low',time:current.time})}}return swings.sort((a,b)=>a.index-b.index)}function detectBOS(candles:Candle[]):BOSResult{if(candles.length<50){return{detected:false,type:null,breakLevel:null,strength:0}}const swings=findSwingPoints(candles);const recentSwings=swings.slice(-8);if(recentSwings.length<5){return{detected:false,type:null,breakLevel:null,strength:0}}const recentHighs=recentSwings.filter(s=>s.type==='high').slice(-3);const recentLows=recentSwings.filter(s=>s.type==='low').slice(-3);const lastCandle=candles[candles.length-1];if(recentHighs.length>=1){const targetHigh=recentHighs[recentHighs.length-1];if(lastCandle.close>targetHigh.price){const breakAmount=lastCandle.close-targetHigh.price;const strength=Math.min(100,60+(breakAmount/targetHigh.price)*10000);return{detected:true,type:'bullish',breakLevel:targetHigh.price,strength}}}if(recentLows.length>=1){const targetLow=recentLows[recentLows.length-1];if(lastCandle.close<targetLow.price){const breakAmount=targetLow.price-lastCandle.close;const strength=Math.min(100,60+(breakAmount/targetLow.price)*10000);return{detected:true,type:'bearish',breakLevel:targetLow.price,strength}}}return{detected:false,type:null,breakLevel:null,strength:0}}function detectLiquiditySweep(candles:Candle[]):LiquiditySweepResult{if(candles.length<40){return{detected:false,sweptLevel:null,sweptType:null,strength:0}}const swings=findSwingPoints(candles);const recentCandles=candles.slice(-20);const recentHighs=swings.filter(s=>s.type==='high').slice(-5);const recentLows=swings.filter(s=>s.type==='low').slice(-5);for(const swingHigh of recentHighs){for(let i=0;i<recentCandles.length;i++){const candle=recentCandles[i];const candleIndex=candles.length-recentCandles.length+i;if(candleIndex<=swingHigh.index)continue;const sweepAmount=candle.high-swingHigh.price;if(sweepAmount>0.00005*swingHigh.price&&(candle.close<swingHigh.price||(i<recentCandles.length-1&&recentCandles[i+1].close<swingHigh.price))){const wickSize=candle.high-Math.max(candle.open,candle.close);const bodySize=Math.abs(candle.close-candle.open);const strength=Math.min(100,60+(wickSize>bodySize?20:0));return{detected:true,sweptLevel:swingHigh.price,sweptType:'high',strength}}}}for(const swingLow of recentLows){for(let i=0;i<recentCandles.length;i++){const candle=recentCandles[i];const candleIndex=candles.length-recentCandles.length+i;if(candleIndex<=swingLow.index)continue;const sweepAmount=swingLow.price-candle.low;if(sweepAmount>0.00005*swingLow.price&&(candle.close>swingLow.price||(i<recentCandles.length-1&&recentCandles[i+1].close>swingLow.price))){const wickSize=Math.min(candle.open,candle.close)-candle.low;const bodySize=Math.abs(candle.close-candle.open);const strength=Math.min(100,60+(wickSize>bodySize?20:0));return{detected:true,sweptLevel:swingLow.price,sweptType:'low',strength}}}}return{detected:false,sweptLevel:null,sweptType:null,strength:0}}function analyzeTrend(candles:Candle[]):{trend:'bullish'|'bearish'|'sideways';strength:number}{if(candles.length<20){return{trend:'sideways',strength:0}}const swings=findSwingPoints(candles);const recentSwings=swings.slice(-6);if(recentSwings.length<4){return{trend:'sideways',strength:0}}const highs=recentSwings.filter(s=>s.type==='high');const lows=recentSwings.filter(s=>s.type==='low');let bullishSignals=0;let bearishSignals=0;for(let i=1;i<highs.length;i++){if(highs[i].price>highs[i-1].price)bullishSignals++;else bearishSignals++}for(let i=1;i<lows.length;i++){if(lows[i].price>lows[i-1].price)bullishSignals++;else bearishSignals++}const total=bullishSignals+bearishSignals;if(total===0)return{trend:'sideways',strength:0};const bullishPercent=(bullishSignals/total)*100;if(bullishPercent>=65){return{trend:'bullish',strength:bullishPercent}}else if(bullishPercent<=35){return{trend:'bearish',strength:100-bullishPercent}}else{return{trend:'sideways',strength:50}}}function detectOrderBlocks(candles:Candle[]):Array<{price:number;type:'bullish'|'bearish';strength:number}>{const orderBlocks:Array<{price:number;type:'bullish'|'bearish';strength:number}>=[];const recent=candles.slice(-30);const avgVolume=recent.reduce((sum,c)=>sum+c.volume,0)/recent.length;for(let i=0;i<recent.length-2;i++){const candle=recent[i];const bodySize=Math.abs(candle.close-candle.open);const candleRange=candle.high-candle.low;if(bodySize/candleRange>0.6&&candle.volume>avgVolume*1.2){const next=recent[i+1];const isBullishOB=candle.close>candle.open&&next.close<next.open;const isBearishOB=candle.close<candle.open&&next.close>next.open;if(isBullishOB){orderBlocks.push({price:(candle.open+candle.close)/2,type:'bullish',strength:70})}else if(isBearishOB){orderBlocks.push({price:(candle.open+candle.close)/2,type:'bearish',strength:70})}}}return orderBlocks.slice(-3)}function detectFVGs(candles:Candle[]):Array<{top:number;bottom:number;type:'bullish'|'bearish'}>{const fvgs:Array<{top:number;bottom:number;type:'bullish'|'bearish'}>=[];const recent=candles.slice(-20);for(let i=0;i<recent.length-2;i++){const candle1=recent[i];const candle2=recent[i+1];const candle3=recent[i+2];if(candle1.high<candle3.low){fvgs.push({top:candle3.low,bottom:candle1.high,type:'bullish'})}if(candle1.low>candle3.high){fvgs.push({top:candle1.low,bottom:candle3.high,type:'bearish'})}}return fvgs.slice(-3)}export function analyzeMarketStructure(candles:Candle[]):MarketStructureAnalysis{const bos=detectBOS(candles);const liquiditySweep=detectLiquiditySweep(candles);const trendAnalysis=analyzeTrend(candles);const orderBlocks=detectOrderBlocks(candles);const fvgs=detectFVGs(candles);const swings=findSwingPoints(candles);const recentSwings=swings.slice(-10);const support=recentSwings.filter(s=>s.type==='low').map(s=>s.price).slice(-3);const resistance=recentSwings.filter(s=>s.type==='high').map(s=>s.price).slice(-3);return{bos,liquiditySweep,trend:trendAnalysis.trend,trendStrength:trendAnalysis.strength,orderBlocks,fvgs,keyLevels:{support,resistance}}}